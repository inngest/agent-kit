---
title: History
description: Learn how to persist conversations for your agents and networks
icon: "database"
iconType: "regular"
---

## Overview

AgentKit enables persistent conversations that maintain context across multiple runs. By implementing a **History Adapter**, you can connect your agents and networks to any database or storage solution, allowing conversations to resume exactly where they left off.

<Note>
  AgentKit is database-agnostic. You can use PostgreSQL, MongoDB, Redis, or any
  storage solution by implementing the `HistoryConfig` interface.
</Note>

## How History Adapters Work

A History Adapter is a configuration object that bridges AgentKit's execution lifecycle with your database. It tells AgentKit how to:

1. **Create** new conversation threads
2. **Load** existing conversation history
3. **Save** new messages and results

The adapter is passed to `createAgent()` or `createNetwork()` and AgentKit automatically calls your adapter's methods at the appropriate times during execution.

## The HistoryConfig Interface

```typescript
interface HistoryConfig<T extends StateData> {
  createThread?: (ctx: CreateThreadContext<T>) => Promise<{ threadId: string }>;
  get?: (ctx: Context<T>) => Promise<AgentResult[]>;
  appendResults?: (
    ctx: Context<T> & {
      newResults: AgentResult[];
      userMessage?: { content: string; role: "user"; timestamp: Date };
    }
  ) => Promise<void>;
}
```

### Usage

Here's a complete example of creating a network with history persistence:

```typescript
import {
  createNetwork,
  createAgent,
  createState,
  openai,
} from "@inngest/agent-kit";
import { db } from "./db"; // Your database client

// Define your history adapter with all three methods
const conversationHistoryAdapter: HistoryConfig<any> = {
  // 1. Create new conversation threads
  createThread: async ({ state, input }) => {
    const thread = await db.thread.create({
      data: {
        userId: state.data.userId,
        title: input.slice(0, 50), // First 50 chars as title
        createdAt: new Date(),
      },
    });
    return { threadId: thread.id };
  },

  // 2. Load conversation history
  get: async ({ threadId }) => {
    if (!threadId) return [];

    const messages = await db.message.findMany({
      where: { threadId },
      orderBy: { createdAt: "asc" },
    });

    // Transform database records to AgentResult format
    return messages
      .filter((msg) => msg.role === "assistant")
      .map((msg) => ({
        agentName: msg.agentName,
        output: [
          {
            type: "text" as const,
            role: "assistant" as const,
            content: msg.content,
          },
        ],
        toolCalls: [],
        createdAt: new Date(msg.createdAt),
      }));
  },

  // 3. Save new messages
  appendResults: async ({ threadId, newResults, userMessage }) => {
    if (!threadId) return;

    // Save user message
    if (userMessage) {
      await db.message.create({
        data: {
          threadId,
          role: "user",
          content: userMessage.content,
          createdAt: userMessage.timestamp,
        },
      });
    }

    // Save agent responses
    for (const result of newResults) {
      const content = result.output
        .filter((msg) => msg.type === "text")
        .map((msg) => msg.content)
        .join("\n");

      await db.message.create({
        data: {
          threadId,
          role: "assistant",
          agentName: result.agentName,
          content,
          createdAt: result.createdAt,
        },
      });
    }
  },
};

// Create agents
const researcher = createAgent({
  name: "researcher",
  description: "Searches for information",
  model: openai({ model: "gpt-4" }),
});

const writer = createAgent({
  name: "writer",
  description: "Writes comprehensive responses",
  model: openai({ model: "gpt-4" }),
});

// Create network with history configuration
const assistantNetwork = createNetwork({
  name: "Research Assistant",
  agents: [researcher, writer],
  defaultModel: openai({ model: "gpt-4" }),
  history: conversationHistoryAdapter, // Add history adapter here
});

// Use the network - conversations will be automatically persisted
const state = createState(
  { userId: "user-123" },
  { threadId: "existing-thread-id" } // Optional: continue existing conversation
);

await assistantNetwork.run("Tell me about quantum computing", { state });
```

### The Three Core Methods

#### 1. `createThread` (Optional)

- **Purpose**: Creates a new conversation thread in your database
- **When called**: At the start of a run if no `threadId` exists in the state
- **Returns**: An object with the new `threadId`

#### 2. `get` (Optional)

- **Purpose**: Retrieves conversation history from your database
- **When called**: After thread initialization, but only if the client didn't provide `results` or `messages`
- **Returns**: Array of `AgentResult[]` representing the conversation history

#### 3. `appendResults` (Optional)

- **Purpose**: Saves new messages to your database after a network or agent run
- **When called**: At the end of a successful agent or network run
- **Receives**: Only the _new_ results generated during this run (prevents duplicates)

## Using the History Adapter

Once you've created your adapter, pass it to the `history` property when creating an agent or network:

<CodeGroup>

```typescript Agent
import { createAgent } from "@inngest/agent-kit";
import { postgresHistoryAdapter } from "./my-postgres-adapter";

const chatAgent = createAgent({
  name: "chat-agent",
  system: "You are a helpful assistant.",
  history: postgresHistoryAdapter, // Add your adapter here
});

// Now the agent will automatically persist conversations
await chatAgent.run("Hello!", {
  state: createState({ userId: "user123" }, { threadId: "thread-456" }),
});
```

```typescript Network
import { createNetwork, createAgent } from "@inngest/agent-kit";
import { postgresHistoryAdapter } from "./my-postgres-adapter";

const chatAgent = createAgent({
  name: "chat-agent",
  system: "You are a helpful assistant.",
});

const chatNetwork = createNetwork({
  name: "Chat Network",
  agents: [chatAgent],
  history: postgresHistoryAdapter, // Add your adapter here
});

// The entire network will use persistent conversations
await chatNetwork.run("Hello!");
```

</CodeGroup>

## Persistence Patterns

AgentKit supports two powerful patterns for managing conversation history:

### Server-Authoritative

The client sends a message with a `threadId`. AgentKit automatically loads the full conversation context from your database before the network runs.

```typescript
// Client sends just the threadId
const state = createState(
  { userId: "user123" },
  { threadId: "existing-thread-id" }
);

await chatNetwork.run("Continue our conversation", { state });
// AgentKit calls history.get() to load full context for all agents
```

**Use case**: Perfect for restoring conversations after page refresh or when opening the app on a new device.

### Client-Authoritative (Performance Optimized)

The client maintains conversation state locally and sends the complete history with each request. AgentKit detects this and skips the database read for better performance.

```typescript
// Client sends the full conversation history
const state = createState(
  { userId: "user123" },
  {
    threadId: "thread-id",
    results: previousConversationResults, // Full history from client
  }
);

await chatNetwork.run("New message", { state });
// AgentKit skips history.get() call - faster performance!
// Still calls history.appendResults() to save new messages
```

**Use case**: Ideal for interactive chat applications where the frontend maintains conversation state.

## Thread ID Management

AgentKit provides flexible thread ID management:

<CardGroup cols={3}>
  <Card title="Explicit" icon="id-card">
    Pass a `threadId` directly to `createState()` to work with a specific
    conversation.
  </Card>
  <Card title="Automatic Creation" icon="plus">
    If no `threadId` is provided, the `createThread()` hook is called to
    generate a new thread.
  </Card>
  <Card title="Auto-Generation" icon="shuffle">
    If `createThread()` isn't defined but `get()` is, a UUID is automatically
    generated.
  </Card>
</CardGroup>

## Database Schema Example

Here's a simple PostgreSQL schema that works well with AgentKit:

```sql
-- Threads table
CREATE TABLE threads (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id VARCHAR(255) NOT NULL,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Messages table
CREATE TABLE messages (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  thread_id UUID NOT NULL REFERENCES threads(id) ON DELETE CASCADE,
  role VARCHAR(20) NOT NULL, -- 'user' or 'assistant'
  content TEXT NOT NULL,
  agent_name VARCHAR(255), -- Which agent generated this (for assistant messages)
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),

  INDEX idx_messages_thread_id (thread_id),
  INDEX idx_messages_created_at (created_at)
);
```

## Best Practices

<AccordionGroup>

  <Accordion title="Leverage Inngest's Durable Steps">
    Wrap database operations in `step.run()` for automatic retries and durability.
    
    ```typescript
    await step.run("database-operation", async () => {
      return await db.someOperation();
    });
    ```
  </Accordion>

  <Accordion title="Handle Missing Threads Gracefully">
    If a thread doesn't exist, return an empty array rather than throwing an error.
    
    ```typescript
    get: async ({ threadId }) => {
      if (!threadId) return [];
      
      const messages = await db.getMessages(threadId);
      return messages || []; // Handle null/undefined gracefully
    }
    ```
  </Accordion>

  <Accordion title="Index Your Database Properly">
    Ensure you have indexes on `thread_id` and `created_at` columns for fast queries.
    
    ```sql
    CREATE INDEX idx_messages_thread_id ON messages(thread_id);
    CREATE INDEX idx_messages_created_at ON messages(created_at);
    ```
  </Accordion>
</AccordionGroup>

## Future Enhancements

The history system provides a foundation for advanced features to be released in the coming future including:

- **Database Adapters**: Pre-built adapters for popular databases (coming soon)
- **Progressive Summarization**: Automatic conversation compression for long threads
- **Search & Retrieval**: Semantic search across conversation history

## Complete Example

Check out the [AgentKit Starter](https://github.com/inngest/agent-kit/tree/main/examples/agentkit-starter) for a complete implementation featuring:

- PostgreSQL history adapter
- ChatGPT-style UI with thread management
- Real-time streaming responses
- Both server and client-authoritative patterns

The starter includes everything you need to build a conversational AI application with persistent history.

---

## Advanced: Execution Lifecycle

Here's when each method in your adapter is called during an `agent.run()` or `network.run()`:

<Steps>
  <Step title="Thread Initialization">
    AgentKit calls `initializeThread()` utility, which invokes your
    `createThread()` hook if no `threadId` exists.
  </Step>
  <Step title="History Loading">
    AgentKit calls `loadThreadFromStorage()` utility, which invokes your `get()`
    hook to populate the agent's memory with conversation history.
    <Note>
      This step is skipped if you provide `messages` or `results` directly to
      `createState()`, enabling client-authoritative optimization.
    </Note>
  </Step>
  <Step title="Agent Execution">
    Your agents run with full conversation context loaded from the database.
  </Step>
  <Step title="Result Persistence">
    AgentKit calls `saveThreadToStorage()` utility, which invokes your
    `appendResults()` hook to save only the new messages generated during this
    run.
  </Step>
</Steps>
