---
title: UI Streaming Overview
description: Event-driven UI streaming with useAgents and AgentKit.
---

### What is UI Streaming?

UI Streaming is the event-driven bridge between your running Agents and your user interface. Instead of stitching together ad‑hoc token streams, your UI receives structured events that describe lifecycle, content parts, tool activity, and completion. The `useAgents` hook consumes these events and maintains a coherent, resilient UI state for a single conversation or many conversations in parallel.

### Why use `useAgents`?

- **Structured events, not just tokens**: `run.*`, `part.*`, `text.delta`, `tool_call.*`, and more.
- **Resilient UI state**: A reducer assembles incremental parts and finalizes them deterministically.
- **Durable execution**: Server uses Inngest steps and AgentKit to generate canonical IDs and safely retry.
- **Threads built-in**: Manage switching, pagination, and unseen indicators in one place.

### How it fits together

```mermaid
graph TD
  UI[Client UI (useAgents)] -->|sendMessage / fetchThreads| HTTP[HTTP Transport]
  HTTP --> INN[Inngest Function]
  INN --> AG[AgentKit Network/Agent]
  AG --> STR[StreamingContext (events)]
  STR --> RT[Realtime]
  RT -->|events: run.*, part.*, *.delta| UI
```

### Core building blocks

- **Client (`useAgents`)**: A single hook that manages messages, thread lists, status, optimistic sends, and connection state. Under the hood, it applies a pure reducer to ordered events and exposes a minimal, predictable UI model.
- **Server (AgentKit)**: Your `Network.run()`/`Agent.run()` emit structured events via `StreamingContext`. IDs are generated inside durable steps for replay-safety, and conversation state can be persisted via `HistoryConfig` hooks.
- **Transports**: A default HTTP transport for `sendMessage`, threads, and history; a token-based realtime subscription; and a session (in‑memory) transport for demo/ephemeral flows.

### Event model at a glance

- **Lifecycle**: `run.started`, `run.completed`, `run.failed`, `run.interrupted`, `stream.ended`
- **Parts**: `part.created` (e.g. `text`, `tool-call`), `part.completed`
- **Deltas**: `text.delta`, `tool_call.arguments.delta` (JSON), `tool_call.output.delta`
- **Other**: `usage.updated`, `metadata.updated`, `hitl.requested` / `hitl.resolved` (HITL UI TBA)

The reducer maps these events into `ConversationMessage` parts (text and tool-call today, extensible to reasoning/data/files) and updates `agentStatus` (`idle`, `thinking`, `calling-tool`, `responding`, `error`).

### Reliability & ordering

- Every event includes a monotonic `sequenceNumber` for deterministic ordering.
- Server-side publishing is best-effort and never blocks agent execution; errors are logged and swallowed.
- Canonical IDs are generated in Inngest steps to keep streaming, persistence, and UI aligned.

### Threads & persistence (high level)

- If the client provides a `threadId`, the server upserts it and loads history only when the client didn’t supply messages (client‑authoritative mode).
- If not, the server can auto‑generate a `threadId` and upsert it for future persistence.
- User messages are persisted at run start; new agent results are saved after the run completes.

### What you’ll build next

- A minimal chat UI with `useAgents`
- Rendering of `text` and `tool-call` parts with incremental updates
- Server hooks for history (create/load/save) and a few simple endpoints
- Confidence in ordering, resuming, and multi-thread usage

### Continue

- useAgents Overview
- Basic Example
- Structured Outputs
- Generative UI
- Persistence
- Thread Management
- Realtime & Events Reference
