---
title: "Building Chat UIs with React Hooks"
description: "Create your first streaming AI chat app with AgentKit in 5 minutes"
---

Build a production-ready AI chat interface in just a few minutes using AgentKit's `@inngest/use-agents` React hooks package. This guide will take you from zero to a fully functional streaming chat app.

<CardGroup>
  <Card
    title="Complete Example"
    href="https://github.com/inngest/agent-kit/tree/main/examples/use-agent"
    icon="github"
  >
    See the full source code for a production-ready chat application
  </Card>
  <Card title="Live Demo" href="https://agent-kit-demo.vercel.app" icon="globe">
    Try the live demo to see streaming in action
  </Card>
</CardGroup>

## Quick Start (5 minutes)

### 1. Installation

```bash
npm install @inngest/use-agents
# Peer dependencies
npm install react @inngest/realtime uuid
```

### 2. Backend Setup

Create a simple Inngest function to handle chat requests:

```typescript title="inngest/functions/chat.ts"
import { inngest } from "../client";
import { userChannel } from "@/lib/realtime";

export const runAgentChat = inngest.createFunction(
  { id: "run-agent-chat" },
  { event: "agent/chat.requested" },
  async ({ event, publish }) => {
    const { threadId, message, userId } = event.data;

    // Your AgentKit network
    const network = createNetwork({
      agents: [yourAgent],
      defaultModel: openai({ model: "gpt-4o" }),
    });

    // Run with automatic streaming
    const result = await network.run(message, {
      streaming: {
        publish: async (chunk) => {
          // Events automatically enriched with context
          await publish(
            userChannel(userId).agent_stream({
              ...chunk,
              data: { ...chunk.data, threadId, userId },
            })
          );
        },
      },
    });

    return { success: true, threadId, result };
  }
);
```

### 3. API Routes

Create the necessary API endpoints:

```typescript title="app/api/chat/route.ts"
import { NextRequest, NextResponse } from "next/server";
import { inngest } from "@/inngest/client";
import { randomUUID } from "crypto";

export async function POST(req: NextRequest) {
  const { message, threadId, userId } = await req.json();

  await inngest.send({
    name: "agent/chat.requested",
    data: {
      threadId: threadId || randomUUID(),
      message,
      userId,
      messageId: randomUUID(),
      history: [], // Add conversation history here
    },
  });

  return NextResponse.json({ success: true, threadId });
}
```

```typescript title="app/api/realtime/token/route.ts"
import { getSubscriptionToken } from "@inngest/realtime";
import { inngest } from "@/inngest/client";
import { userChannel } from "@/lib/realtime";

export async function POST(req: NextRequest) {
  const { userId } = await req.json();

  const token = await getSubscriptionToken(inngest, {
    channel: userChannel(userId),
    topics: ["agent_stream"],
  });

  return NextResponse.json(token);
}
```

### 4. React Application

Now build your chat UI with just a few lines of React:

```typescript title="app/page.tsx"
import { Chat } from "@/components/Chat";
import { AgentProvider } from "@inngest/use-agents";

export default function Home() {
  return (
    <AgentProvider userId="user-123" debug={true}>
      <Chat />
    </AgentProvider>
  );
}
```

```typescript title="components/Chat.tsx"
"use client";

import { useChat } from "@inngest/use-agents";

export function Chat() {
  const {
    messages,
    sendMessage,
    status,
    isConnected,
    threads,
    createNewThread,
  } = useChat();

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    const formData = new FormData(e.currentTarget);
    const message = formData.get("message") as string;

    if (message.trim()) {
      await sendMessage(message);
      e.currentTarget.reset();
    }
  };

  return (
    <div className="flex h-screen">
      {/* Thread Sidebar */}
      <div className="w-64 bg-gray-50 border-r">
        <button onClick={createNewThread}>+ New Chat</button>
        {threads.map(thread => (
          <div key={thread.id} className="p-2 hover:bg-gray-100">
            {thread.title}
          </div>
        ))}
      </div>

      {/* Chat Area */}
      <div className="flex-1 flex flex-col">
        <div className="flex-1 overflow-y-auto p-4">
          <div>Status: {status}</div>
          <div>Connected: {isConnected ? "Yes" : "No"}</div>

          {messages.map(msg => (
            <div key={msg.id} className={`mb-4 ${msg.role}`}>
              <strong>{msg.role}:</strong>
              {msg.parts.map((part, i) => (
                <div key={i}>
                  {part.type === 'text' && part.content}
                  {part.type === 'tool-call' && (
                    <div className="bg-blue-50 p-2 rounded">
                      Tool: {part.toolName} ({part.state})
                      {part.output && <div>Result: {JSON.stringify(part.output)}</div>}
                    </div>
                  )}
                </div>
              ))}
            </div>
          ))}
        </div>

        <form onSubmit={handleSubmit} className="border-t p-4">
          <input
            name="message"
            placeholder="Ask anything..."
            disabled={status !== "idle"}
            className="w-full p-2 border rounded"
          />
          <button
            type="submit"
            disabled={status !== "idle"}
            className="mt-2 px-4 py-2 bg-blue-500 text-white rounded"
          >
            Send
          </button>
        </form>
      </div>
    </div>
  );
}
```

üéâ **That's it!** You now have a fully functional streaming chat app with:

- Real-time message streaming
- Thread management with sidebar
- Tool call visualization
- Connection status indicators
- Error handling and recovery

## Understanding the Magic

### What Just Happened?

1. **AgentProvider** established a WebSocket connection to your user's channel
2. **useChat** combined real-time streaming (`useAgent`) with thread management (`useThreads`)
3. **sendMessage** triggered your Inngest function via `/api/chat`
4. **StreamingContext** automatically captured and published agent events
5. **useAgent** received events via WebSocket and updated React state
6. **Your UI** re-rendered in real-time as the agent responded

### Key Benefits You Get

- **Immediate Feedback**: Users see typing indicators, tool calls, reasoning
- **Multi-thread Support**: Background updates for inactive conversations
- **Optimistic Updates**: Threads appear in sidebar before backend confirms
- **Error Recovery**: Graceful handling of network issues and failures
- **State Management**: Perfect synchronization between real-time and persistent data

## Next Steps: Enhanced Features

### Add Message Actions

```typescript
import { useMessageActions } from "@inngest/use-agents";

const { copyMessage, likeMessage, shareMessage } = useMessageActions({
  showToast: (message, type) => {
    // Your toast implementation
    toast[type](message);
  }
});

// In your message rendering:
<button onClick={() => copyMessage(message)}>Copy</button>
<button onClick={() => likeMessage(message.id)}>üëç</button>
```

### Enable Message Editing

```typescript
import { useEditMessage, useConversationBranching } from "@inngest/use-agents";

const { editingMessage, handleEditMessage, handleSaveEdit } = useEditMessage({
  sendMessage: async (newContent) => {
    // Handle conversation branching automatically
    await sendMessage(newContent, { editFromMessageId: editingMessage });
  },
});
```

### Add Human-in-the-Loop

```typescript
const { approveToolCall, denyToolCall } = useChat();

// In your tool call rendering:
{part.type === 'tool-call' && part.state === 'awaiting-approval' && (
  <div>
    <button onClick={() => approveToolCall(part.toolCallId)}>
      ‚úÖ Approve
    </button>
    <button onClick={() => denyToolCall(part.toolCallId, reason)}>
      ‚ùå Deny
    </button>
  </div>
)}
```

### Capture Client State

```typescript
const chat = useChat({
  // Capture UI context with each message for debugging/regeneration
  state: () => ({
    currentPage: window.location.pathname,
    formData: getCurrentFormData(),
    userPreferences: getUserSettings(),
    timestamp: Date.now(),
  }),

  // Restore UI state when editing messages
  onStateRehydrate: (messageState, messageId) => {
    if (messageState.currentPage) {
      router.push(messageState.currentPage);
    }
    if (messageState.formData) {
      restoreFormData(messageState.formData);
    }
  },
});
```

## Production Patterns

### URL-driven Chat Pages

```typescript title="app/chat/[threadId]/page.tsx"
import { AgentProvider } from "@inngest/use-agents";
import { Chat } from "@/components/Chat";

export default async function ThreadPage({ params }) {
  const { threadId } = await params;

  return (
    <AgentProvider userId="user-123" debug={false}>
      <Chat threadId={threadId} />
    </AgentProvider>
  );
}
```

### Custom Transport Configuration

```typescript
import { createDefaultAgentTransport } from "@inngest/use-agents";

const customTransport = createDefaultAgentTransport({
  api: {
    sendMessage: '/api/v2/chat',
    fetchThreads: '/api/v2/conversations',
  },
  headers: {
    'Authorization': `Bearer ${getAuthToken()}`,
    'X-API-Version': '2.0'
  }
});

<AgentProvider transport={customTransport}>
  <ChatApp />
</AgentProvider>
```

### Ephemeral/Demo Mode

```typescript
import { useEphemeralThreads } from "@inngest/use-agents";

const ephemeralThreads = useEphemeralThreads({
  userId: "demo-user",
  storageType: "session", // Clears on tab close
});

const chat = useChat({
  userId: "demo-user",
  enableThreadValidation: false, // No backend database
  ...ephemeralThreads,
});
```

## Common Patterns

### Multi-Chat Interface

```typescript
// Multiple concurrent chats (like our SQL Playground)
function MultiChatApp() {
  const [tabs, setTabs] = useState([{ id: uuid(), threadId: uuid() }]);

  return (
    <AgentProvider userId="user-123">
      {tabs.map(tab => (
        <ChatTab key={tab.id} threadId={tab.threadId} />
      ))}
    </AgentProvider>
  );
}
```

### Anonymous User Support

```typescript
// No userId required - automatic anonymous ID generation
<AgentProvider debug={true}>
  <GuestChat />
</AgentProvider>
```

### Collaborative Sessions

```typescript
// Multiple users on same conversation
<AgentProvider channelKey="project-123" userId="user-456">
  <CollaborativeChat />
</AgentProvider>
```

## Troubleshooting

### Common Issues

**"No messages appearing"**

- Verify your Inngest function is running and published correctly
- Check that `userChannel` is configured properly
- Ensure your agent is actually generating streaming events

**"Events arriving out of order"**

- This is normal! useAgent automatically buffers and reorders events
- Check console for sequence number debugging info

**"Connection keeps dropping"**

- Verify your `/api/realtime/token` endpoint is working
- Check for authentication/authorization issues
- Review network connectivity and proxy configurations

**"Hook not updating"**

- Ensure components are wrapped with `AgentProvider`
- Verify `userId` is provided either to provider or hook
- Check that streaming events include the correct `threadId`

### Debug Mode

Enable comprehensive logging:

```typescript
<AgentProvider userId="user-123" debug={true}>
  <ChatApp />
</AgentProvider>
```

This provides detailed console output for:

- Connection establishment and status
- Event processing and sequence numbers
- Thread switching and message reconciliation
- Transport requests and responses

## Next Steps

<CardGroup>
  <Card title="Hook Selection Guide" href="/streaming/hook-selection-guide">
    Choose the right hook for your specific use case
  </Card>
  <Card title="Provider Pattern Deep Dive" href="/streaming/provider-pattern">
    Optimize performance with shared connections
  </Card>
  <Card title="Complete API Reference" href="/reference/react-hooks/use-chat">
    Comprehensive documentation for all hook options
  </Card>
  <Card
    title="Advanced Examples"
    href="/advanced-patterns/conversation-branching"
  >
    Message editing, branching, and advanced UI patterns
  </Card>
</CardGroup>

Congratulations! You've built a sophisticated streaming AI chat interface that rivals the best AI applications. The combination of AgentKit's automatic streaming with our React hooks provides a foundation that scales from simple demos to production applications serving millions of users.
